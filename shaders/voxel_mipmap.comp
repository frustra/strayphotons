#version 430

##import voxel_shared
##import lib/util
##import lib/types_common

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0, rgb10_a2ui) readonly uniform uimage2D currentFragmentList;
layout (binding = 1, rgb10_a2ui) writeonly uniform uimage2D nextFragmentList;
layout (binding = 2, r32ui) writeonly uniform uimage3D currentVoxelCounters;
layout (binding = 3, r32ui) uniform uimage3D nextVoxelCounters;

layout (binding = 4, rgba16f) readonly uniform image3D previousVoxelRadiance;
layout (binding = 5, rgba16f) writeonly uniform image3D currentVoxelRadiance;

layout (binding = 0) uniform atomic_uint currentFragListSize;
layout (binding = 1) uniform atomic_uint nextFragListSize;
layout (binding = 1, offset = 4) uniform atomic_uint nextComputeSize;

layout(binding = 0, std140) uniform GLVoxelInfo {
	VoxelInfo voxelInfo;
};

uniform int mipLevel = 0;

#define MIPMAP_POSITION(mipPosition, map, level) ((mipPosition) + ivec3((map) * VOXEL_GRID_SIZE >> (level), 0, 0))

void main() {
	uint index = gl_WorkGroupID.x * (gl_WorkGroupSize.x * gl_WorkGroupSize.y) + gl_LocalInvocationIndex;
	uint size = atomicCounter(currentFragListSize);
	if (index >= size) return;

	ivec3 position = ivec3(imageLoad(currentFragmentList, ivec2(index & MaxFragListMask[mipLevel], index >> FragListWidthBits[mipLevel])).xyz);

	imageStore(currentVoxelCounters, position, uvec4(0));

	if (mipLevel > 0) {
		ivec3 floorPosition = position << 1;

		float alpha = 0.0;
		vec3[MAX_VOXEL_AREAS] radiance;
		for (int i = 0; i < MAX_VOXEL_AREAS; i++) radiance[i] = vec3(0);

		for (int x = 0; x < 2; x++) {
			for (int y = 0; y < 2; y++) {
				for (int z = 0; z < 2; z++) {
					ivec3 samplePos = floorPosition + ivec3(x, y, z);
					vec4 sampleValue = imageLoad(previousVoxelRadiance, samplePos);

					if (mipLevel == 1) {
						vec3 samplePosWorld = vec3(samplePos - VOXEL_GRID_SIZE * 0.5 + 0.5) * voxelInfo.size + voxelInfo.center;
						for (int i = 0; i < MAX_VOXEL_AREAS; i++) {
							float inArea = float(samplePosWorld == clamp(samplePosWorld, voxelInfo.areas[i].areaMin, voxelInfo.areas[i].areaMax));
							radiance[i] += sampleValue.rgb * inArea;
						}
					} else {
						radiance[0] += sampleValue.rgb;
						for (int i = 1; i < MAX_VOXEL_AREAS; i++) {
							radiance[i] += imageLoad(previousVoxelRadiance, MIPMAP_POSITION(samplePos, i, mipLevel - 1)).rgb;
						}
					}
					sampleValue.a = min(sampleValue.a, 1.0);
					alpha += sampleValue.a;
				}
			}
		}

		// Bias alpha so that 50% full is opaque
		alpha = saturate(alpha * 0.25);

		// 0.25 looks good, don't touch it ¯\_(ツ)_/¯
		for (int i = 0; i < MAX_VOXEL_AREAS; i++) {
			imageStore(currentVoxelRadiance, MIPMAP_POSITION(position, i, mipLevel), vec4(radiance[i] * 0.25, alpha));
		}
	}

	if (mipLevel < VOXEL_MIP_LEVELS - 1) {
		uint count = imageAtomicAdd(nextVoxelCounters, position >> 1, 1);
		if (count == 0) {
			uint nextIndex = atomicCounterIncrement(nextFragListSize);
			if (nextIndex % MipmapWorkGroupSize == 0) atomicCounterIncrement(nextComputeSize);
			imageStore(nextFragmentList, ivec2(nextIndex & MaxFragListMask[mipLevel + 1], nextIndex >> FragListWidthBits[mipLevel + 1]), uvec4(position >> 1, 1.0));
		}
	}
}
