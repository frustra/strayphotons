/*
 * Stray Photons - Copyright (C) 2025 Jacob Wirth
 *
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

#include "../lib/types_common.glsl"
#include "../lib/util.glsl"

layout(binding = 0) uniform sampler3D voxelRadiance;
layout(binding = 1) uniform sampler3D voxelNormals;

layout(binding = 2, rgba16f) uniform image2DArray radianceOut;

INCLUDE_LAYOUT(binding = 3)
#include "lib/view_states_uniform.glsl"

layout(binding = 4) uniform VoxelStateUniform {
    VoxelState voxelInfo;
};

layout(constant_id = 0) const int CASCADE_NUM = 0;
layout(constant_id = 1) const int BASE_SAMPLES = 4;
layout(constant_id = 2) const int NEXT_SAMPLES = 4;
layout(constant_id = 3) const float SAMPLE_LENGTH = 4;
layout(constant_id = 4) const float VOXEL_SCALE = 1;
layout(constant_id = 5) const uint RS_RESOLUTION_X = 256;
layout(constant_id = 6) const uint RS_RESOLUTION_Y = 256;

#include "../lib/voxel_shared.glsl"
#include "lib/rc_shared.glsl"

void main() {
    if (any(greaterThanEqual(gl_GlobalInvocationID, imageSize(radianceOut)))) return;
    ivec3 xyr = ivec3(gl_GlobalInvocationID);

    ViewState view = views[0];
    vec3 viewPos = view.invViewMat[3].xyz;
	viewPos.y -= voxelSampleOffset;
    vec3 viewVoxelPos = (voxelInfo.worldToVoxel * vec4(viewPos, 1.0)).xyz / vec3(voxelInfo.gridSize.x, 1, voxelInfo.gridSize.z);

	float thetaMult = 2.0 * M_PI / imageSize(radianceOut).z;
	float theta = xyr.z * thetaMult + thetaMult * 0.5;
	vec2 startPos = vec2(xyr.xy * (1 << CASCADE_NUM));
	vec2 lastPoint = startPos;
	float radius = 0.0;
	for (int i = 0; i < CASCADE_NUM; i++) {
		float numSamples = BASE_SAMPLES * pow(NEXT_SAMPLES, i);
		float cascadeThetaMult = 2.0 * M_PI / numSamples;
		float cascadeTheta = floor(theta / cascadeThetaMult) * cascadeThetaMult + cascadeThetaMult * 0.5;
		vec2 sampleDir = vec2(sin(cascadeTheta), cos(cascadeTheta));

		float relativeScale = pow(NEXT_SAMPLES, CASCADE_NUM - i);
		float intervalLength = SAMPLE_LENGTH * sin((M_PI - thetaMult * relativeScale) * 0.5) / sin(thetaMult * relativeScale);
		radius += intervalLength;
		lastPoint = startPos + sampleDir * radius;
	}
	vec2 sampleDir = vec2(sin(theta), cos(theta));
	radius += SAMPLE_LENGTH * sin((M_PI - thetaMult) * 0.5) / sin(thetaMult);
	vec2 endPos = startPos + sampleDir * radius;
	vec2 cascadeScale = 1.0 / vec2(RS_RESOLUTION_X, RS_RESOLUTION_X);
	vec4 sampleValue = TraceGridLineScaled(lastPoint * cascadeScale, endPos * cascadeScale, viewVoxelPos.y);
	// vec4 sampleValue = TraceSceneLine(startPos, endPos, viewVoxelPos.xz, VOXEL_SCALE * cascadeScale.x);

    imageStore(radianceOut, xyr, sampleValue);
}
