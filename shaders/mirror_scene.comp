#version 430

##import lib/types_common

layout (local_size_x = MAX_MIRRORS, local_size_y = MAX_MIRRORS) in;

##import lib/mirror_scene_common

uniform int mirrorCount = 0;

layout (binding = 0, std140) uniform GLMirrorData {
	Mirror mirrors[MAX_MIRRORS];
};

void main() {
	if (gl_LocalInvocationIndex == 0) {
		bool firstPass = mirrorSData.count[2] == 0;

		int prevCount = max(1, mirrorSData.count[0]);
		for (int i = mirrorSData.count[1]; i < prevCount; i++) {
			for (int j = 0; j < mirrorCount; j++) {
				if (mirrorSData.mask[i][j] == 1) {
					uint index = mirrorSData.count[0]++;
					mirrorSData.list[index] = PackSourceAndMirror(i, j, firstPass);

					mirrorSData.mask[i][j] = 0;
				}
			}
		}

		mirrorSData.count[1] = mirrorSData.count[2];
		mirrorSData.count[2] = mirrorSData.count[0];
	}

	barrier();
	memoryBarrier();

	uint index = gl_LocalInvocationIndex + mirrorSData.count[1];
	if (index >= mirrorSData.count[0]) return;

	uint tuple = mirrorSData.list[index];
	int mirrorId = UnpackMirrorDest(tuple);

	if (MirrorSourceIsMirror(tuple)) {
		int sourceIndex = UnpackMirrorSource(tuple);
		mirrorSData.reflectMat[index] = mirrorSData.reflectMat[sourceIndex] * mirrors[mirrorId].reflectMat;
	} else {
		mirrorSData.reflectMat[index] = mirrors[mirrorId].reflectMat;
	}

	mirrorSData.invReflectMat[index] = inverse(mirrorSData.reflectMat[index]);

	vec4 plane = mirrors[mirrorId].plane;
	plane.w -= 0.0001;
	mirrorSData.clipPlane[index] = plane;
}