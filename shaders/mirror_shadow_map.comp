#version 430

##import lib/types_common
##import lib/mirror_shadow_common

layout (local_size_x = MAX_LIGHTS, local_size_y = MAX_MIRRORS) in;

uniform int lightCount = 0;
uniform int mirrorCount = 0;

layout(binding = 0, std140) uniform GLLightData {
	Light lights[MAX_LIGHTS];
};

layout(binding = 1, std140) uniform GLMirrorData {
	Mirror mirrors[MAX_MIRRORS];
};

mat4 makeProjectionMatrix(vec3 viewSpaceMirrorPos, vec2 clip, vec2 size, vec4 bounds) {
	return mat4(
		2*clip.x/size.x,            0,                          0,                                0,
		0,                          2*clip.x/size.y,            0,                                0,
		(bounds.y+bounds.x)/size.x, (bounds.z+bounds.w)/size.y, -(clip.y+clip.x)/(clip.y-clip.x), -1,
		0,                          0,                          -2*clip.y*clip.x/(clip.y-clip.x), 0
	);
}

void main() {
	if (gl_LocalInvocationIndex == 0) {
		bool firstPass = mirrorData.count[2] == 0;

		int prevCount = max(lightCount, mirrorData.count[0]);
		for (int i = mirrorData.count[1]; i < prevCount; i++) {
			for (int j = 0; j < mirrorCount; j++) {
				if (mirrorData.mask[i][j] == 1) {
					uint index = mirrorData.count[0]++;
					mirrorData.list[index] = PackSourceAndMirror(i, j, firstPass);
					mirrorData.sourceLight[index] = firstPass ? i : mirrorData.sourceLight[i];

					mirrorData.mask[i][j] = 0;
				}
			}
		}

		mirrorData.count[1] = mirrorData.count[2];
		mirrorData.count[2] = mirrorData.count[0];
	}

	barrier();
	memoryBarrier();

	uint index = gl_LocalInvocationIndex + mirrorData.count[1];
	if (index >= mirrorData.count[0]) return;

	uint tuple = mirrorData.list[index];
	int sourceId = UnpackMirrorSource(tuple);
	int mirrorId = UnpackMirrorDest(tuple);

	vec3 mirrorNormal = mirrors[mirrorId].plane.xyz;
	vec3 mirrorPos = vec3(mirrors[mirrorId].modelMat * vec4(0, 0, 0, 1));

	vec3 sourcePos;
	mat4 sourceViewMat;

	if (MirrorSourceIsMirror(tuple)) {
		sourcePos = vec3(mirrorData.invViewMat[sourceId] * vec4(0, 0, 0, 1));
		sourceViewMat = mirrorData.lightViewMat[sourceId];
	} else {
		sourcePos = lights[sourceId].position;
		sourceViewMat = lights[sourceId].view;
	}

	vec3 focalPoint = mat3(mirrors[mirrorId].reflectMat) * (sourcePos - mirrorPos);

	mat4 mirrorViewMat = inverse(mirrors[mirrorId].modelMat);
	mat4 translation = mat4(1);
	translation[3] = vec4(-focalPoint, 1.0);
	mirrorViewMat = mirrorViewMat * translation;

	vec3 viewSpaceMirrorPos = vec3(mirrorViewMat * vec4(mirrorPos, 1.0));
	vec2 clip = vec2(-viewSpaceMirrorPos.z + 0.0001, -viewSpaceMirrorPos.z + 64);
	vec2 size = mirrors[mirrorId].size;
	vec4 bounds = viewSpaceMirrorPos.xxyy + vec4(-size.x, size.x, -size.y, size.y) * 0.5;

	mirrorData.viewMat[index] = mirrorViewMat;
	mirrorData.projMat[index] = makeProjectionMatrix(viewSpaceMirrorPos, clip, size, bounds);
	mirrorData.invViewMat[index] = inverse(mirrorData.viewMat[index]);
	mirrorData.invProjMat[index] = inverse(mirrorData.projMat[index]);
	mirrorData.lightViewMat[index] = sourceViewMat * mirrors[mirrorId].reflectMat;
	mirrorData.invLightViewMat[index] = inverse(mirrorData.lightViewMat[index]);
	mirrorData.clip[index] = clip;
	mirrorData.nearInfo[index] = vec4(bounds.xz, size);
}